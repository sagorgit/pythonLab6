# pythonLab6
# Отчёт по лабораторной работе

Тема: Сравнение реализаций построения бинарного дерева
Вариант: №14
Студент: Сагор Мд Афсар Уддин(470709)
Язык реализации: Python


---

1. Постановка задачи

Нужно было сравнить время работы двух реализаций функции построения бинарного дерева:
– рекурсивной (через вызовы функции самой себя),
– нерекурсивной (через цикл и явную структуру данных, например список).

Также рассмотреть влияние кэширования на скорость построения.
Всего выполнено четыре сравнения:

1. Рекурсивный и нерекурсивный (оба без кэша)


2. Рекурсивный без кэша и рекурсивный с кэшем


3. Нерекурсивный без кэша и с кэшем


4. Рекурсивный и нерекурсивный с кэшем




---

2. Индивидуальный вариант №14

Параметры для генерации дерева:

root = 14  
height = 4 (для проверки структуры, далее использовался диапазон 4–16)  
left = 2 - (root - 1) = 3 - root  
right = root * 2

Таким образом, левый потомок вычисляется как 3 - value, а правый — как value * 2.


---

3. Реализация

Работа выполнена на Python 3.
Для измерения времени использовался модуль timeit.
Для визуализации — библиотека matplotlib.

В одном файле binary_tree_step3.py реализованы:

build_tree_recursive() – рекурсивное построение;

build_tree_iterative() – нерекурсивное построение;

их кэшированные версии через functools.lru_cache;

функции для бенчмарков, сохранения CSV и построения графиков.


Для честных и стабильных замеров использовались:

repeat = 9  
number = 50  
heights = 4..16

Эти параметры позволили усреднить шум и получить плавные графики.


---

4. Результаты

В результате были построены четыре графика:

1. Рекурсивный и нерекурсивный (без кэша)
– Разница по времени минимальна, линии местами перекрываются.
– Это логично, так как при небольшой глубине накладные расходы рекурсии ещё несущественны.
– Итеративный метод чуть быстрее из-за отсутствия вызовов функции и стековых операций.


2. Рекурсивный без кэша и рекурсивный с кэшем
– При “холодном” кэше улучшение невелико.
– При “тёплом” (когда значения повторяются) скорость возрастает, так как повторные вычисления потомков берутся из памяти.


3. Нерекурсивный без кэша и с кэшем
– Поведение аналогично рекурсивному: при малых высотах эффект кэша почти не виден.


4. Рекурсивный и нерекурсивный с кэшем
– Обе версии показывают ускорение по сравнению с безкэшовыми.
– Итеративная всё равно немного быстрее, но разница небольшая.



В целом время построения растёт примерно экспоненциально с увеличением высоты дерева,
потому что на каждом уровне количество узлов удваивается.


---

5. Выводы

1. Рост времени:
С увеличением высоты дерева (height) время построения растёт для всех реализаций,
так как объём работы (число узлов) увеличивается по степени 2.


2. Рекурсивный vs Нерекурсивный:
Итеративная версия обычно немного быстрее из-за отсутствия накладных расходов на вызовы функций и стек рекурсии.


3. Влияние кэша:
Эффект кэширования зависит от того, встречаются ли одинаковые значения узлов.
При частых совпадениях повторные вычисления потомков действительно берутся из памяти,
и время сокращается.


4. Причина малого различия на графике:
При небольших высотах и малых абсолютных временах разница между подходами статистически мала —
линии на графиках могут перекрываться. Это нормальная ситуация, если задачи выполняются очень быстро.


5. Общее заключение:
Все четыре эксперимента подтверждают корректность работы функций.
Итеративный метод более устойчив к росту высоты,
рекурсивный — проще в реализации, но чуть медленнее при больших размерах дерева.
Кэширование даёт эффект в задачах с повторяющимися подвычислениями.




---

6. Использованные файлы

Имя файла	Назначение

binary_tree_step2.py	базовые функции без графиков
binary_tree_step3.py	все четыре сравнения, построение графиков
exp1_rec_vs_it_no_cache.png	график №1
exp2_rec_nc_vs_rec_cached.png	график №2
exp3_it_nc_vs_it_cached.png	график №3
exp4_rec_cached_vs_it_cached.png	график №4
.csv файлы с теми же именами	таблицы с числовыми результатами



---

7. Примечание студента

> При выполнении лабораторной я увеличил repeat и number, чтобы получить стабильные результаты и убрать влияние случайных колебаний времени.
Графики показывают общий рост времени при увеличении высоты, а небольшие различия между кривыми объясняются малым масштабом задач.
Все результаты соответствуют ожидаемой теории, а структура дерева для варианта №14 построена корректно.
